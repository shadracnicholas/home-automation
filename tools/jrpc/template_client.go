package main

import (
	"fmt"
	"path"
	"strings"
	"text/template"

	"github.com/shadracnicholas/home-automation/tools/jrpc/imports"
)

type clientDataEndpoint struct {
	NameUpper  string
	InputType  string
	OutputType string
	HTTPMethod string
	URL        string
}

type clientData struct {
	PackageName string
	Imports     []*imports.Imp
	ServiceName string
	Endpoints   []*clientDataEndpoint
}

const clientTemplateText = `// Code generated by jrpc. DO NOT EDIT.

package {{ .PackageName }}

{{ if .Imports }}
	import (
		{{- range .Imports }}
			{{ .Alias }} "{{ .Path }}"
		{{- end}}
	)
{{- end }}

// {{ .ServiceName }}Service is the public interface of this service
type {{ .ServiceName }}Service interface {
	{{- range .Endpoints }}
		{{ .NameUpper }}(ctx context.Context, body *{{ .InputType }}) *{{ .NameUpper }}Future
	{{- end }}
}

{{- range $endpoint := .Endpoints }}
	// {{ $endpoint.NameUpper }}Future represents an in-flight {{ $endpoint.NameUpper }} request
	type {{ $endpoint.NameUpper }}Future struct {
		done <-chan struct{}
		rsp *{{ $endpoint.OutputType }}
		err error
	}

	// Wait blocks until the response is ready
	func (f *{{ $endpoint.NameUpper }}Future) Wait() (*{{ $endpoint.OutputType }}, error) {
		<-f.done
		return f.rsp, f.err
	}
{{- end }}

// {{ .ServiceName }}Client makes requests to this service
type {{ .ServiceName }}Client struct {
	dispatcher taxi.Dispatcher
}

// Compile-time assertion that the client implements the interface
var _ {{ .ServiceName }}Service = (*{{ .ServiceName }}Client)(nil)

// New{{ .ServiceName }}Client returns a new client
func New{{ .ServiceName }}Client(d taxi.Dispatcher) *{{ .ServiceName }}Client {
	return &{{ .ServiceName }}Client{
		dispatcher: d,
	}
}

{{- range $endpoint := .Endpoints }}
	// {{ $endpoint.NameUpper }} dispatches an RPC to the service
	func (c *{{ $.ServiceName }}Client) {{ $endpoint.NameUpper }}(ctx context.Context, body *{{ $endpoint.InputType }}) *{{ $endpoint.NameUpper }}Future {
		taxiFtr := c.dispatcher.Dispatch(ctx, &taxi.RPC{
			Method: "{{ $endpoint.HTTPMethod }}",
			URL: "{{ $endpoint.URL }}",
			Body: body,
		})

		done := make(chan struct{})
		ftr := &{{ $endpoint.NameUpper }}Future{
			done: done,
		}

		go func() {
			defer close(done)
			ftr.err = taxiFtr.DecodeResponse(&ftr.rsp)
		}()

		return ftr
	}
{{- end }}

// Mock{{ .ServiceName }}Client can be used in tests
type Mock{{ .ServiceName }}Client struct {
	dispatcher *taxi.MockClient
}

// Compile-time assertion that the mock client implements the interface
var _ {{ .ServiceName }}Service = (*Mock{{ .ServiceName }}Client)(nil)

// NewMock{{ .ServiceName }}Client returns a new mock client
func NewMock{{ .ServiceName }}Client(ctx context.Context, t *testing.T) *Mock{{ .ServiceName }}Client {
	f := taxi.NewTestFixture(t)

	return &Mock{{ .ServiceName }}Client{
		dispatcher: &taxi.MockClient{Handler: f},
	}
}

{{- range $endpoint := .Endpoints }}
	// {{ $endpoint.NameUpper }} dispatches an RPC to the mock client
	func (c *Mock{{ $.ServiceName }}Client) {{ $endpoint.NameUpper }}(ctx context.Context, body *{{ $endpoint.InputType }}) *{{ $endpoint.NameUpper }}Future {
		taxiFtr := c.dispatcher.Dispatch(ctx, &taxi.RPC{
			Method: "{{ $endpoint.HTTPMethod }}",
			URL: "{{ $endpoint.URL }}",
			Body: body,
		})

		done := make(chan struct{})
		ftr := &{{ $endpoint.NameUpper }}Future{
			done: done,
		}

		go func() {
			defer close(done)
			ftr.err = taxiFtr.DecodeResponse(&ftr.rsp)
		}()

		return ftr
	}
{{- end }}

`

type clientGenerator struct {
	baseGenerator
}

func (g *clientGenerator) Template() (*template.Template, error) {
	return template.New("client_template").Parse(clientTemplateText)
}

func (g *clientGenerator) PackageDir() string {
	return packageDirExternal
}

func (g *clientGenerator) Data(im *imports.Manager) (interface{}, error) {
	im.Add("context")
	im.Add("github.com/shadracnicholas/home-automation/libraries/go/taxi")

	if g.file.Service == nil {
		return nil, nil
	}

	if len(g.file.Service.RPCs) == 0 {
		return nil, nil
	}

	routerPath, ok := g.file.Service.Options["path"].(string)
	if !ok {
		return nil, fmt.Errorf("path not set on service %q", g.file.Service.Name)
	}

	endpoints := make([]*clientDataEndpoint, len(g.file.Service.RPCs))
	for i, r := range g.file.Service.RPCs {
		nameUpper := strings.ToUpper(r.Name[0:1]) + r.Name[1:]

		method, err := getMethod(r)
		if err != nil {
			return nil, fmt.Errorf("failed to get RPC %q method: %w", r.Name, err)
		}

		rpcPath, err := getPath(r)
		if err != nil {
			return nil, fmt.Errorf("failed to get RPC %q path: %w", r.Name, err)
		}

		inType, err := resolveTypeName(r.InputType, g.file, im)
		if err != nil {
			return nil, fmt.Errorf("failed to resolve RPC %q input type: %w", r.Name, err)
		}

		outType, err := resolveTypeName(r.OutputType, g.file, im)
		if err != nil {
			return nil, fmt.Errorf("failed to resolve RPC %q output type: %w", r.Name, err)
		}

		endpoints[i] = &clientDataEndpoint{
			NameUpper:  nameUpper,
			InputType:  inType.TypeName,
			OutputType: outType.TypeName,
			HTTPMethod: method,
			URL:        path.Join(routerPath, rpcPath),
		}
	}

	return &clientData{
		PackageName: externalPackageName(g.options),
		Imports:     im.Get(),
		ServiceName: g.file.Service.Name,
		Endpoints:   endpoints,
	}, nil
}

func (g *clientGenerator) Filename() string {
	return "client.go"
}
